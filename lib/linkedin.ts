// lib/linkedin.ts

/**
 * --- LinkedIn API Integration Notes ---
 *
 * LinkedIn's API uses OAuth 2.0 for authentication. Accessing detailed user data
 * requires specific permissions (scopes) and often involves app verification by LinkedIn.
 *
 * Base URLs:
 * - Authorization: https://www.linkedin.com/oauth/v2/authorization
 * - Access Token: https://www.linkedin.com/oauth/v2/accessToken
 * - API (general): https://api.linkedin.com/v2/ or https://api.linkedin.com/rest/
 *
 * Permissions (Scopes) Required (examples, actual names might vary slightly):
 * - openid: For OpenID Connect authentication.
 * - profile: Access to basic profile information (name, photo, headline). Replaces r_liteprofile.
 * - email: Access to the user's primary email address. Replaces r_emailaddress.
 * - For more detailed information like work experience, education, and skills,
 *   your application might need to apply for Standard Tier access and specific product permissions from LinkedIn.
 *   The exact scopes would be like `r_member_social` (less relevant here) or specific V2 API permissions.
 *   Historically, `r_fullprofile` was used, but it's deprecated.
 *   Modern approach might involve specific projections on /me or other endpoints.
 *   For this initial setup, we will request `openid profile email`.
 *   Fetching full experience, education, and skills reliably requires elevated permissions.
 *
 * App Verification:
 * - Most applications needing more than basic "Sign In with LinkedIn" functionality
 *   will need to be verified by LinkedIn through their developer portal.
 *
 * OAuth Flow:
 * 1. User clicks "Connect LinkedIn" in our app.
 * 2. User is redirected to LinkedIn's authorization URL (generated by `getLinkedInAuthorizationUrl`).
 * 3. User logs in to LinkedIn and grants permissions.
 * 4. LinkedIn redirects back to our `LINKEDIN_REDIRECT_URI` with an authorization `code`.
 * 5. Our backend (at `LINKEDIN_REDIRECT_URI`) exchanges this `code` for an `accessToken`
 *    (using `exchangeCodeForToken`).
 * 6. This `accessToken` is then used to make API calls (in `fetchLinkedInData`).
 *
 * Token Storage:
 * - Access tokens (and refresh tokens, if applicable) must be stored securely,
 *   associated with the user. This is critical and not fully implemented in this initial subtask.
 *
 * Environment Variables:
 * - LINKEDIN_CLIENT_ID: Your application's Client ID from LinkedIn Developer Portal.
 * - LINKEDIN_CLIENT_SECRET: Your application's Client Secret.
 * - LINKEDIN_REDIRECT_URI: The callback URL registered in your LinkedIn app settings.
 *   (e.g., http://localhost:3000/api/oauth/linkedin/callback or your production equivalent)
 */

export interface LinkedInProfile {
  id: string;
  firstName?: string;
  lastName?: string;
  headline?: string;
  summary?: string; // Often part of a more detailed profile fetch
  profilePictureUrl?: string;
  vanityName?: string; // e.g., "john-doe" in linkedin.com/in/john-doe
  location?: string;
  email?: string; // Requires 'email' scope
}

export interface LinkedInPosition {
  companyName: string;
  title: string;
  description?: string;
  startDate?: { year?: number; month?: number };
  endDate?: { year?: number; month?: number };
  location?: string;
  isCurrent: boolean;
}

export interface LinkedInEducationEntry {
  schoolName: string;
  degreeName?: string;
  fieldOfStudy?: string;
  startDate?: { year?: number };
  endDate?: { year?: number };
  description?: string;
}

export interface LinkedInSkill {
  name: string;
  // proficiency?: string; // LinkedIn skill endorsements/proficiency are complex
}

// This type should align with the structure of portfolioContent in generator.ts
// For now, it's a partial representation of what we aim to populate.
export interface PartialPortfolioContentFromLinkedIn {
  name?: string; // From LinkedInProfile: firstName + lastName
  bio?: string; // From LinkedInProfile: headline or summary
  summary?: string; // From LinkedInProfile: summary
  avatar?: string; // From LinkedInProfile: profilePictureUrl
  email?: string; // From LinkedInProfile: email
  location?: string; // From LinkedInProfile: location
  experience?: LinkedInPosition[];
  education?: LinkedInEducationEntry[];
  skills?: string[]; // Array of skill names
  // linkedInProfileUrl: string; // This would be constructed or from vanityName
}

const LINKEDIN_API_BASE_URL = "https://api.linkedin.com/rest"; // Using newer REST API base

/**
 * Constructs the LinkedIn authorization URL.
 */
export function getLinkedInAuthorizationUrl(): string {
  const clientId = process.env.LINKEDIN_CLIENT_ID;
  const redirectUri = process.env.LINKEDIN_REDIRECT_URI;

  if (!clientId || !redirectUri) {
    console.error("LinkedIn Client ID or Redirect URI is not configured.");
    return "/error/linkedin-config-missing"; // Or throw an error
  }

  const params = new URLSearchParams({
    response_type: "code",
    client_id: clientId,
    redirect_uri: redirectUri,
    scope: "openid profile email", // Basic scopes. Add more if app gets approval.
    // state: 'SOME_CSRF_TOKEN' // Recommended for security
  });
  return `https://www.linkedin.com/oauth/v2/authorization?${params.toString()}`;
}

/**
 * Exchanges an authorization code for an access token.
 */
export async function exchangeCodeForToken(code: string): Promise<string | null> {
  const clientId = process.env.LINKEDIN_CLIENT_ID;
  const clientSecret = process.env.LINKEDIN_CLIENT_SECRET;
  const redirectUri = process.env.LINKEDIN_REDIRECT_URI;

  if (!clientId || !clientSecret || !redirectUri) {
    console.error("LinkedIn OAuth credentials or Redirect URI are not configured.");
    return null;
  }

  const tokenUrl = "https://www.linkedin.com/oauth/v2/accessToken";
  const body = new URLSearchParams({
    grant_type: "authorization_code",
    code: code,
    redirect_uri: redirectUri,
    client_id: clientId,
    client_secret: clientSecret,
  });

  try {
    const response = await fetch(tokenUrl, {
      method: "POST",
      headers: { "Content-Type": "application/x-www-form-urlencoded" },
      body: body.toString(),
    });

    if (!response.ok) {
      const errorData = await response.json().catch(() => ({}));
      console.error("Error exchanging LinkedIn code for token:", response.status, errorData);
      return null;
    }

    const data = await response.json();
    return data.access_token || null;
  } catch (error) {
    console.error("Exception during LinkedIn token exchange:", error);
    return null;
  }
}

/**
 * Fetches LinkedIn profile data using an access token.
 * This is a placeholder and will need significant expansion based on granted API permissions.
 *
 * @param accessToken - The user's LinkedIn access token.
 * @returns A promise that resolves to partial portfolio content.
 */
export async function fetchLinkedInData(accessToken: string): Promise<PartialPortfolioContentFromLinkedIn> {
  if (!accessToken) {
    console.warn("No LinkedIn access token provided for data fetching.");
    return {};
  }

  let fetchedData: PartialPortfolioContentFromLinkedIn = {};

  try {
    // 1. Fetch basic profile information (OpenID Connect UserInfo endpoint)
    const userInfoResponse = await fetch(`${LINKEDIN_API_BASE_URL}/userinfo`, {
      headers: { Authorization: `Bearer ${accessToken}` },
    });

    if (userInfoResponse.ok) {
      const profileData = await userInfoResponse.json();
      fetchedData.name = `${profileData.given_name || ""} ${profileData.family_name || ""}`.trim();
      fetchedData.email = profileData.email;
      fetchedData.avatar = profileData.picture;
      // The /userinfo endpoint is standard OpenID and might not contain headline/summary.
      // For those, a call to /me with specific projections is usually needed.
    } else {
      console.warn("Failed to fetch LinkedIn userinfo:", userInfoResponse.status, await userInfoResponse.text());
    }

    // 2. Fetch more detailed profile including headline, summary, positions, education, skills
    //    This endpoint (`/me` with projections) is subject to stricter permissions.
    //    The projection syntax might vary. Example: `(id,localizedFirstName,localizedLastName,headline,vanityName,profilePicture(displayImage~:playableStreams),summary,positions,educations,skills)`
    //    For this initial setup, we'll attempt a basic /me and then specific fields if accessible.

    const meResponse = await fetch(`${LINKEDIN_API_BASE_URL}/me?projection=(id,localizedFirstName,localizedLastName,localizedHeadline,localizedSummary,profilePicture(displayImage~:elements*(identifiers*(identifier))))`, {
       headers: { Authorization: `Bearer ${accessToken}`, "Accept-Language": "en_US" },
    });

    if (meResponse.ok) {
        const meData = await meResponse.json();
        if (!fetchedData.name && meData.localizedFirstName && meData.localizedLastName) {
            fetchedData.name = `${meData.localizedFirstName} ${meData.localizedLastName}`;
        }
        fetchedData.headline = meData.localizedHeadline?.localized?.en_US || meData.localizedHeadline; // Example, structure can be complex
        fetchedData.summary = meData.localizedSummary?.localized?.en_US || meData.localizedSummary; // Example
        if (!fetchedData.avatar && meData.profilePicture?.['displayImage~']?.elements?.[0]?.identifiers?.[0]?.identifier) {
             fetchedData.avatar = meData.profilePicture['displayImage~'].elements[0].identifiers[0].identifier;
        }
    } else {
        console.warn("Failed to fetch LinkedIn /me basic profile:", meResponse.status, await meResponse.text());
    }


    // --- Placeholder for fetching Experience, Education, Skills ---
    // These would require separate API calls or more complex projections on /me,
    // and are highly dependent on approved application permissions.
    // Example structure (actual API calls would be needed):
    // fetchedData.experience = await fetchLinkedInField(accessToken, "positions");
    // fetchedData.education = await fetchLinkedInField(accessToken, "educations");
    // fetchedData.skills = (await fetchLinkedInField(accessToken, "skills"))?.map(s => s.name);

    console.log("Fetched LinkedIn Data (Partial):", fetchedData);
    return fetchedData;

  } catch (error) {
    console.error("Error fetching data from LinkedIn:", error);
    return {
        ...fetchedData, // return whatever was fetched before error
        error: "Failed to fetch some LinkedIn data."
    } as any; // Cast to avoid type error on 'error' field
  }
}

/**
 * --- Helper function placeholder for fetching specific fields ---
 * This is a conceptual placeholder. Actual implementation depends on LinkedIn API structure for these fields.
 */
// async function fetchLinkedInField(accessToken: string, field: string): Promise<any[] | null> {
//   try {
//     const response = await fetch(`${LINKEDIN_API_BASE_URL}/me?projection=(${field})`, {
//       headers: { Authorization: `Bearer ${accessToken}` },
//     });
//     if (!response.ok) {
//       console.warn(`Failed to fetch LinkedIn ${field}:`, response.status, await response.text());
//       return null;
//     }
//     const data = await response.json();
//     return data[field] || []; // Assuming the field name is the key in the response
//   } catch (error) {
//     console.error(`Error fetching LinkedIn ${field}:`, error);
//     return null;
//   }
// }

// --- Further Development Notes ---
// - Secure Token Storage: Implement robust server-side storage for access and refresh tokens.
// - Token Refresh: LinkedIn tokens expire. Implement logic to use refresh tokens to get new access tokens.
// - Granular Permissions: Apply for and handle more specific permissions if needed for detailed data.
// - Webhooks: Consider using LinkedIn webhooks for real-time updates (if applicable).
// - Comprehensive Error Handling: Add more specific error handling for different API responses.
// - API Versioning: Be mindful of LinkedIn API version changes. Using "X-Restli-Protocol-Version: 2.0.0" header might be needed.
// - User Experience: The OAuth redirect flow needs careful handling on the frontend and backend.
// - Data Mapping: The transformation from LinkedIn's complex data structures to our simplified
//   PortfolioContentType will need refinement as more fields are accessed.
// - Rate Limiting: Implement strategies to handle API rate limits gracefully.
